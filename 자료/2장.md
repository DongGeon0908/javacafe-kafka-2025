# JavaCafe Kafka 2025

### 메세지 == 레코드
- 카프카에서 흐르는 데이터를 의미

### 메세지, 레코드의 구성

**Key (키)**
- 레코드의 키는 메시지를 특정 파티션에 할당하는 데 사용
- 같은 키는 항상 같은 파티션에 저장 (해시 기반).
- 키는 null일 수도 있음. 이 경우 Kafka는 라운드로빈 방식으로 파티션을 선택 -> 파티션 할당에 필요함.

**Value (값)**
- 실제 전달하고자 하는 메시지 본문
- 문자열, JSON, 바이너리 등 어떤 형식 전부 가능
- Kafka는 데이터의 구조나 형식을 강제하지 않음 (하지만 보통 Avro, JSON, Protobuf 같은 포맷을 사용)

**Timestamp (타임스탬프)**
- 레코드 생성 시간
- 기본적으로 프로듀서가 설정하며, 브로커가 덮어쓸 수 있음
- Kafka는 타임스탬프 기반으로 메시지를 정렬하거나 보존 정책에 사용

**Headers (헤더) - 선택 사항**
- Kafka 0.11부터 도입된 기능으로, 메타데이터를 키-값 쌍 형태로 첨부 가능
- 메시지 자체는 변경하지 않고도 추가 정보를 담을 수 있어서, 시스템 간 연동 시 유용

### 1. 순차 처리나 파티션 지정이 필요 없는 경우
- 특정 파티션에 할당할 필요가 없을 때는 Key를 넣지 않아도 됩니다.
- Kafka는 **라운드로빈 방식**으로 자동으로 파티션을 분산시킵니다.

```json
Key: null
Value: { "message": "오늘의 공지사항입니다." }

### 2. 단순 로그 수집 시스템 (Log Aggregation)
- 서비스 로그 데이터를 Kafka로 수집하는 경우 Key가 필요 없는 경우가 많습니다.

```json
Key: null
Value: { "level": "INFO", "message": "Service started", "timestamp": 1679000000 }

### 주의할 점
- 같은 파티션 내에서만 메세지 순서 보장이 가능하기 때문에, key가 없다면 파티션이 다르게 배정될 수 있어서 순서가 섞일 수 있음.
