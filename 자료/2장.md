# JavaCafe Kafka 2025

### 메세지 == 레코드
- 카프카에서 흐르는 데이터를 의미

<br>

### 메세지, 레코드의 구성

**Key (키)**
- 레코드의 키는 메시지를 특정 파티션에 할당하는 데 사용
- 같은 키는 항상 같은 파티션에 저장 (해시 기반).
- 키는 null일 수도 있음. 이 경우 Kafka는 라운드로빈 방식으로 파티션을 선택 -> 파티션 할당에 필요함.

**Value (값)**
- 실제 전달하고자 하는 메시지 본문
- 문자열, JSON, 바이너리 등 어떤 형식 전부 가능
- Kafka는 데이터의 구조나 형식을 강제하지 않음 (하지만 보통 Avro, JSON, Protobuf 같은 포맷을 사용)

**Timestamp (타임스탬프)**
- 레코드 생성 시간
- 기본적으로 프로듀서가 설정하며, 브로커가 덮어쓸 수 있음
- Kafka는 타임스탬프 기반으로 메시지를 정렬하거나 보존 정책에 사용

**Headers (헤더) - 선택 사항**
- Kafka 0.11부터 도입된 기능으로, 메타데이터를 키-값 쌍 형태로 첨부 가능
- 메시지 자체는 변경하지 않고도 추가 정보를 담을 수 있어서, 시스템 간 연동 시 유용

<br>
<br>

### 1. 순차 처리나 파티션 지정이 필요 없는 경우
- 특정 파티션에 할당할 필요가 없을 때는 Key를 넣지 않아도 됩니다.
- Kafka는 **라운드로빈 방식**으로 자동으로 파티션을 분산시킵니다.

```json
Key: null
Value: { "message": "오늘의 공지사항입니다." }
```

### 2. 단순 로그 수집 시스템 (Log Aggregation)
- 서비스 로그 데이터를 Kafka로 수집하는 경우 Key가 필요 없는 경우가 많습니다.

```json
Key: null
Value: { "level": "INFO", "message": "Service started", "timestamp": 1679000000 }
```

<br>
<br>

### 주의할 점
- 같은 파티션 내에서만 메세지 순서 보장이 가능하기 때문에, key가 없다면 파티션이 다르게 배정될 수 있어서 순서가 섞일 수 있음.

<br>
<br>

#### Kafka - Key가 있을 때와 없을 때의 동작 처리 방식 비교

Kafka에서 **레코드(Key-Value 구조)**에서 **Key의 존재 유무에 따라 메시지가 파티션에 분배되고 처리되는 방식이 달라진다**.

---

## ✅ 1. Key가 **있는 경우**

- Kafka는 **Key를 기반으로 해시(Hashing)**를 수행하여 **지정된 파티션으로 메시지를 라우팅**합니다.
- 동일한 Key는 항상 **같은 파티션으로 보내지기 때문에 순서 보장이 가능합니다**.

### 📌 특징
- **해시 함수(hash(key)) % 파티션 수**로 파티션 선택
- **동일 Key → 동일 파티션 → 순서 보장**
- 파티션을 고정할 수 있어 **데이터 그룹핑이나 파티셔닝 처리에 유리**

### 📤 예시 동작
| Key           | Value                                | 파티션 |
|---------------|--------------------------------------|--------|
| "user123"     | { "event": "login" }                 | 1      |
| "user123"     | { "event": "logout" }                | 1      |
| "user456"     | { "event": "purchase" }              | 2      |

---

## 🚫 2. Key가 **없는 경우 (null)**

- Kafka는 Key가 없을 경우, **라운드로빈(Round-Robin)** 방식 또는 **기타 파티셔너 정책**에 따라 **임의의 파티션에 분산**합니다.
- **순서 보장 불가**: 동일한 종류의 메시지도 **다른 파티션으로 분산**될 수 있음.
- 로드 밸런싱이나 고속 병렬 처리 목적일 때 사용.

### 📌 특징
- **임의 파티션 분배**
- **메시지 순서 보장 X**
- **균등 분산으로 처리량 최적화 가능**

### 📤 예시 동작
| Key   | Value                                | 파티션 |
|-------|--------------------------------------|--------|
| null  | { "event": "login", "user": "u1" }   | 0      |
| null  | { "event": "logout", "user": "u2" }  | 2      |
| null  | { "event": "purchase", "user": "u3"} | 1      |

---

## 🔍 비교 요약

| 항목                     | Key 있음                                | Key 없음                          |
|--------------------------|------------------------------------------|-----------------------------------|
| 파티션 라우팅 방식        | Key 기반 해시                            | 라운드로빈 또는 임의 분산         |
| 메시지 순서              | Key 단위로 순서 보장                    | 순서 보장 어려움                  |
| 처리 목적                | 그룹핑, 파티션 제어, 순서 중요 처리    | 병렬 처리, 부하 분산 목적         |
| 사용 예시                | 사용자 이벤트 스트림, 트랜잭션 로그    | 시스템 로그, 센서 데이터, ETL     |

---

## ✅ 결론
- **순서가 중요한 데이터는 반드시 Key를 사용해야 합니다.**
- **대량 분산처리가 목적일 때는 Key 없이 보내는 것이 유리할 수 있습니다.**


