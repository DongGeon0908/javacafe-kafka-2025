# JavaCafe Kafka 2025

### 메세지 == 레코드
- 카프카에서 흐르는 데이터를 의미

<br>

### 메세지, 레코드의 구성

**Key (키)**
- 레코드의 키는 메시지를 특정 파티션에 할당하는 데 사용
- 같은 키는 항상 같은 파티션에 저장 (해시 기반).
- 키는 null일 수도 있음. 이 경우 Kafka는 라운드로빈 방식으로 파티션을 선택 -> 파티션 할당에 필요함.

**Value (값)**
- 실제 전달하고자 하는 메시지 본문
- 문자열, JSON, 바이너리 등 어떤 형식 전부 가능
- Kafka는 데이터의 구조나 형식을 강제하지 않음 (하지만 보통 Avro, JSON, Protobuf 같은 포맷을 사용)

**Timestamp (타임스탬프)**
- 레코드 생성 시간
- 기본적으로 프로듀서가 설정하며, 브로커가 덮어쓸 수 있음
- Kafka는 타임스탬프 기반으로 메시지를 정렬하거나 보존 정책에 사용

**Headers (헤더) - 선택 사항**
- Kafka 0.11부터 도입된 기능으로, 메타데이터를 키-값 쌍 형태로 첨부 가능
- 메시지 자체는 변경하지 않고도 추가 정보를 담을 수 있어서, 시스템 간 연동 시 유용

<br>
<br>

### 1. 순차 처리나 파티션 지정이 필요 없는 경우
- 특정 파티션에 할당할 필요가 없을 때는 Key를 넣지 않아도 됩니다.
- Kafka는 **라운드로빈 방식**으로 자동으로 파티션을 분산시킵니다.

```json
Key: null
Value: { "message": "오늘의 공지사항입니다." }
```

### 2. 단순 로그 수집 시스템 (Log Aggregation)
- 서비스 로그 데이터를 Kafka로 수집하는 경우 Key가 필요 없는 경우가 많습니다.

```json
Key: null
Value: { "level": "INFO", "message": "Service started", "timestamp": 1679000000 }
```

<br>
<br>

### 주의할 점
- 같은 파티션 내에서만 메세지 순서 보장이 가능하기 때문에, key가 없다면 파티션이 다르게 배정될 수 있어서 순서가 섞일 수 있음.

<br>
<br>

#### Kafka - Key가 있을 때와 없을 때의 동작 처리 방식 비교

Kafka에서 **레코드(Key-Value 구조)**에서 **Key의 존재 유무에 따라 메시지가 파티션에 분배되고 처리되는 방식이 달라진다**.

---

## ✅ 1. Key가 **있는 경우**

- Kafka는 **Key를 기반으로 해시(Hashing)**를 수행하여 **지정된 파티션으로 메시지를 라우팅**합니다.
- 동일한 Key는 항상 **같은 파티션으로 보내지기 때문에 순서 보장이 가능합니다**.

### 📌 특징
- **해시 함수(hash(key)) % 파티션 수**로 파티션 선택
- **동일 Key → 동일 파티션 → 순서 보장**
- 파티션을 고정할 수 있어 **데이터 그룹핑이나 파티셔닝 처리에 유리**

### 📤 예시 동작
| Key           | Value                                | 파티션 |
|---------------|--------------------------------------|--------|
| "user123"     | { "event": "login" }                 | 1      |
| "user123"     | { "event": "logout" }                | 1      |
| "user456"     | { "event": "purchase" }              | 2      |

---

## 🚫 2. Key가 **없는 경우 (null)**

- Kafka는 Key가 없을 경우, **라운드로빈(Round-Robin)** 방식 또는 **기타 파티셔너 정책**에 따라 **임의의 파티션에 분산**합니다.
- **순서 보장 불가**: 동일한 종류의 메시지도 **다른 파티션으로 분산**될 수 있음.
- 로드 밸런싱이나 고속 병렬 처리 목적일 때 사용.

### 📌 특징
- **임의 파티션 분배**
- **메시지 순서 보장 X**
- **균등 분산으로 처리량 최적화 가능**

### 📤 예시 동작
| Key   | Value                                | 파티션 |
|-------|--------------------------------------|--------|
| null  | { "event": "login", "user": "u1" }   | 0      |
| null  | { "event": "logout", "user": "u2" }  | 2      |
| null  | { "event": "purchase", "user": "u3"} | 1      |

---

## 🔍 비교 요약

| 항목                     | Key 있음                                | Key 없음                          |
|--------------------------|------------------------------------------|-----------------------------------|
| 파티션 라우팅 방식        | Key 기반 해시                            | 라운드로빈 또는 임의 분산         |
| 메시지 순서              | Key 단위로 순서 보장                    | 순서 보장 어려움                  |
| 처리 목적                | 그룹핑, 파티션 제어, 순서 중요 처리    | 병렬 처리, 부하 분산 목적         |
| 사용 예시                | 사용자 이벤트 스트림, 트랜잭션 로그    | 시스템 로그, 센서 데이터, ETL     |

---

### 그래서 결론
- 순서 보장 필요시 key 넣기
- 순서 보장 없는 케이스의 경우, key 필요하지 않음

<br>
<br>

</hr>

### 카프카 브로커란?
> Kafka 브로커는 메시지를 저장하고, 생산자(Producer)와 소비자(Consumer) 간의 데이터를 중개하는 서버입니다. 여러 브로커가 모여 Kafka 클러스터를 구성합니다.

<br>
<br>

</hr>

### Kafka - 파티션이 3개일 때 리더 선출 방식

Kafka에서는 **각 파티션마다 "리더(Leader)" 브로커가 존재**하며, 실제 데이터의 **생산(Write) 및 소비(Read)는 리더 파티션을 통해 이루어집니다**.

---

## ✅ 기본 개념 정리

- Kafka의 **토픽(Topic)**은 **여러 파티션(Partition)**으로 구성됩니다.
- 각 파티션은 **복제(replica)**될 수 있으며, **복제본 중 하나가 "리더(Leader)"**, 나머지는 **팔로워(Follower)**가 됩니다.
- **리더는 클라이언트와 직접 통신**하며, 팔로워는 리더의 데이터를 복제만 합니다.

---

## 📌 예시: 파티션이 3개일 때

| 파티션 | 리더 브로커 | 팔로워 브로커 |
|--------|-------------|----------------|
| P0     | 브로커 1    | 브로커 2, 브로커 3 |
| P1     | 브로커 2    | 브로커 1, 브로커 3 |
| P2     | 브로커 3    | 브로커 1, 브로커 2 |

※ 이 예시는 복제 계수(replication factor)가 3일 때입니다.

---

## ⚙️ 리더 선출 방식

### 1. **초기 리더 선출**
- 토픽 생성 시 Kafka의 **파티셔너/컨트롤러 브로커**가 각 파티션의 리더를 결정합니다.
- **Round-Robin 방식** 또는 **Rack-Aware 전략** 등을 활용해 **브로커에 고르게 분산**되도록 배치합니다.

### 파티셔너/컨트롤러 브로커
- **파티셔너(Partitioner)**: Producer 측에서 메시지를 어떤 파티션에 보낼지 결정하는 로직 또는 전략입니다. (브로커가 아니라 Producer 내부의 기능입니다.)
- **컨트롤러 브로커(Controller Broker)**: Kafka 클러스터에서 파티션의 리더 선출, 브로커 상태 관리 등 클러스터를 관리하는 역할을 담당하는 브로커입니다. 클러스터 내 브로커 중 하나가 컨트롤러로 자동 선출됩니다.


### 2. **리더 장애 시 리더 재선출 (Failover)**
- 기존 리더 브로커가 장애나 다운이 되면, **팔로워 중 ISR(In-Sync Replica)**에 있는 브로커가 새로운 리더로 선출됩니다.
- **Kafka Controller 브로커**가 이 과정을 관리합니다.

> ISR = 리더와 동일한 데이터 상태를 유지하고 있는 팔로워 복제본 리스트

### 3. **선출 우선순위**
- Kafka는 ISR 목록에서 가장 먼저 준비된 복제본을 리더로 선출합니다.
- 단, Kafka 설정에 따라 **기존 리더 복구 시 다시 리더로 되돌릴 수도 있습니다** (`unclean.leader.election.enable` 설정 여부에 따라 다름).

---

## 📌 리더 선출 관련 주요 설정

| 설정 항목 | 설명 |
|------------|-----------------------------|
| `replication.factor` | 각 파티션의 복제 개수 |
| `unclean.leader.election.enable` | true일 경우, ISR 밖 복제본도 리더로 선출 가능 (데이터 유실 위험) |
| `min.insync.replicas` | ISR에 포함되어야 하는 최소 복제본 수 (생산 가능 조건) |

---

## ✅ 요약

| 항목 | 설명 |
|------|-------------------------------|
| 리더 역할 | 생산자/소비자와 직접 통신하는 주체 |
| 리더 선정 시점 | 토픽 생성 시 자동 지정 |
| 장애 처리 | ISR 내 팔로워에서 자동 선출 |
| 컨트롤러 역할 | 리더 관리 및 선출 담당 |

---

<br>
<br>

</hr>

### 토픽이란?
- Kafka에서 **토픽(Topic)**은 메시지를 분류하고 저장하는 논리적인 단위
- 메시지를 보내고 받는 통로이자 카테고리

```
예시: "user-login-events", "order-created", "system-logs" 같은 이름으로 사용됩니다.
```

- **생산자(Producer)**는 메시지를 특정 토픽으로 보냅니다.
- **소비자(Consumer)**는 원하는 토픽을 구독하여 메시지를 읽습니다.
- 하나의 토픽은 여러 개의 파티션으로 나뉘며, 파티션을 통해 확장성과 병렬처리가 가능

### Kafka에서 Zookeeper의 용도

> Kafka는 **클러스터의 메타데이터와 상태 관리를 위해 Zookeeper를 사용**

---

### ✅ Zookeeper의 주요 역할

1. **브로커 등록 및 상태 감시**
   - 클러스터 내 브로커들의 **등록/해제 및 헬스 체크**를 담당
2. **컨트롤러 선출**
   - Kafka 클러스터 내 **컨트롤러 브로커(리더 관리 역할)**를 선출
3. **토픽 및 파티션 메타데이터 관리**
   - 토픽 생성 정보, 파티션 개수, 복제본 위치 등의 **메타데이터를 저장**
4. **리더 파티션 관리**
   - 각 파티션의 **리더 정보와 ISR(In-Sync Replica) 목록**을 관리

---

## 📌 Kafka without Zookeeper?
Kafka 2.8.0부터는 **Zookeeper 없이 운영 가능한 "KRaft 모드(Kafka Raft Metadata mode)"**가 도입되어,  
향후에는 **Zookeeper가 완전히 제거될 예정**입니다.

### Zookeeper가 완전히 사장될 것인가?

